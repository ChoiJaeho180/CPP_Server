#include "pch.h"
#include "Lock.h"
#include "CoreTLS.h"

void Lock::WriteLock()
{
	// 동일한 쓰레드가 소유하고 있다면 무조건 성공
	const uint32 lockThreadId = (this->_lockFlag.load() & WRITE_THREAD_MASK) >> 16;
	if (lockThreadId == LThreadId) {
		this->_writeCount++;
		return;
	}

	// 아무도 소유 및 공유하고 있지 않을 때, 경합해서 소유권을 얻는다.
	// 소유 = [WWWWWWWW][WWWWWWWW]
	// 공유 = [RRRRRRRR][RRRRRRRR]
	const int64 beginTick = ::GetTickCount64();
	const uint32 desired = ((LThreadId << 16) & WRITE_THREAD_MASK);
	while (true) {
		for (uint32 spinCount = 0; spinCount < MAX_SPIN_COUNT; spinCount++) {
			uint32 expected  = EMPTY_FLAG;
			if (this->_lockFlag.compare_exchange_strong(OUT expected, desired)) {
				this->_writeCount++;
				return;
			}
		}

		const int64 curTick = ::GetTickCount64();
		if (curTick - beginTick >= ACQUIRE_TIMEOUT_TICK) {
			CRASH("LOCK_TIMEOUT");
		}

		this_thread::yield();
	}
}

void Lock::WriteUnlock()
{	
	// ReadLock 다 풀기 전에는 WriteUnlock 불가능
	if ((this->_lockFlag.load() & READ_COUNT_MASK) != 0) {
		CRASH("INVALID_UNLOCK_ORDER");
	}

	const int32 lockCount = --_writeCount;
	if (lockCount == 0) {
		this->_lockFlag.store(EMPTY_FLAG);
	}
}

void Lock::ReadLock()
{
	// 동일한 쓰레드가 소유하고 있다면 무조건 성공
	const uint32 lockThreadId = (this->_lockFlag.load() & WRITE_THREAD_MASK) >> 16;
	if (lockThreadId == LThreadId) {
		this->_lockFlag.fetch_add(1);
		return;
	}

	// 아무도 소유학 ㅗ있지 않을 떄 경합해서 공유 카운트를 올린다.
	const int64 beginTick = ::GetTickCount64();
	while (true) {
		for (uint32 spinCount = 0; spinCount < MAX_SPIN_COUNT; spinCount++) {
			uint32 expected = (this->_lockFlag.load() & READ_COUNT_MASK);
			if (this->_lockFlag.compare_exchange_strong(OUT expected, expected + 1)) {
				return;
			}

		}
		
		const int64 curTick = ::GetTickCount64();
		if (curTick - beginTick >= ACQUIRE_TIMEOUT_TICK) {
			CRASH("LOCK_TIMEOUT");
		}

		this_thread::yield();
	}
}

void Lock::ReadUnlock()
{	
	// fetch_sub은 빼기 전의 값을 반환
	// 0이 반환된 경우 문제가 있는 상황.
	if ((this->_lockFlag.fetch_sub(1) & READ_COUNT_MASK) == 0) {
		CRASH("MULTIPLX_UNLOCK");
	}

}
